From dae445d94a7a5e1ad38719ea05e5bb0bc76ede84 Mon Sep 17 00:00:00 2001
From: Campbell Barton <ideasman42@gmail.com>
Date: Sat, 13 Feb 2021 22:57:01 +1100
Subject: [PATCH] Fix T85573: Building with Python 3.10a5 fails

Replace deprecated _PyUnicode_AsString{AndSize} usage.

T83626 still needs to be resolved before 3.10 is usable.
---
 intern/cycles/blender/blender_python.cpp      |  2 +-
 .../freestyle/intern/python/BPy_SShape.cpp    |  2 +-
 source/blender/python/bmesh/bmesh_py_ops.c    |  2 +-
 .../blender/python/bmesh/bmesh_py_ops_call.c  |  4 +-
 .../python/bmesh/bmesh_py_types_customdata.c  |  4 +-
 source/blender/python/generic/idprop_py_api.c | 16 ++---
 source/blender/python/generic/imbuf_py_api.c  |  2 +-
 source/blender/python/generic/py_capi_utils.c | 22 +++---
 source/blender/python/gpu/gpu_py_api.c        |  2 +-
 .../blender/python/gpu/gpu_py_vertex_format.c |  4 +-
 source/blender/python/intern/bpy.c            |  4 +-
 .../python/intern/bpy_app_translations.c      |  8 +--
 source/blender/python/intern/bpy_capi_utils.c |  6 +-
 source/blender/python/intern/bpy_driver.c     |  4 +-
 source/blender/python/intern/bpy_interface.c  |  6 +-
 .../blender/python/intern/bpy_library_load.c  |  2 +-
 source/blender/python/intern/bpy_msgbus.c     |  2 +-
 source/blender/python/intern/bpy_operator.c   |  2 +-
 .../blender/python/intern/bpy_operator_wrap.c |  2 +-
 source/blender/python/intern/bpy_props.c      | 17 +++--
 source/blender/python/intern/bpy_rna.c        | 70 +++++++++----------
 source/blender/python/intern/bpy_traceback.c  |  2 +-
 .../python/mathutils/mathutils_Euler.c        |  2 +-
 .../python/mathutils/mathutils_Matrix.c       |  4 +-
 .../python/mathutils/mathutils_Quaternion.c   |  2 +-
 25 files changed, 96 insertions(+), 97 deletions(-)

diff --git a/intern/cycles/blender/blender_python.cpp b/intern/cycles/blender/blender_python.cpp
index 5646bd5b2eb0..0daad310543d 100644
--- a/intern/cycles/blender/blender_python.cpp
+++ b/intern/cycles/blender/blender_python.cpp
@@ -147,7 +147,7 @@ void python_thread_state_restore(void **python_thread_state)
 
 static const char *PyC_UnicodeAsByte(PyObject *py_str, PyObject **coerce)
 {
-  const char *result = _PyUnicode_AsString(py_str);
+  const char *result = PyUnicode_AsUTF8(py_str);
   if (result) {
     /* 99% of the time this is enough but we better support non unicode
      * chars since blender doesn't limit this.
diff --git a/source/blender/freestyle/intern/python/BPy_SShape.cpp b/source/blender/freestyle/intern/python/BPy_SShape.cpp
index f43a464d99ed..0ea02d8a3f60 100644
--- a/source/blender/freestyle/intern/python/BPy_SShape.cpp
+++ b/source/blender/freestyle/intern/python/BPy_SShape.cpp
@@ -201,7 +201,7 @@ static int SShape_name_set(BPy_SShape *self, PyObject *value, void *UNUSED(closu
     PyErr_SetString(PyExc_TypeError, "value must be a string");
     return -1;
   }
-  const char *name = _PyUnicode_AsString(value);
+  const char *name = PyUnicode_AsUTF8(value);
   self->ss->setName(name);
   return 0;
 }
diff --git a/source/blender/python/bmesh/bmesh_py_ops.c b/source/blender/python/bmesh/bmesh_py_ops.c
index c5d72a00ce3b..b23891ca1fe6 100644
--- a/source/blender/python/bmesh/bmesh_py_ops.c
+++ b/source/blender/python/bmesh/bmesh_py_ops.c
@@ -245,7 +245,7 @@ static PyTypeObject bmesh_op_Type = {
 
 static PyObject *bpy_bmesh_ops_module_getattro(PyObject *UNUSED(self), PyObject *pyname)
 {
-  const char *opname = _PyUnicode_AsString(pyname);
+  const char *opname = PyUnicode_AsUTF8(pyname);
 
   if (BMO_opcode_from_opname(opname) != -1) {
     return bpy_bmesh_op_CreatePyObject(opname);
diff --git a/source/blender/python/bmesh/bmesh_py_ops_call.c b/source/blender/python/bmesh/bmesh_py_ops_call.c
index d0676ec19471..28daf08507d6 100644
--- a/source/blender/python/bmesh/bmesh_py_ops_call.c
+++ b/source/blender/python/bmesh/bmesh_py_ops_call.c
@@ -184,7 +184,7 @@ static int bpy_slot_from_py(BMesh *bm,
       if (slot->slot_subtype.intg == BMO_OP_SLOT_SUBTYPE_INT_ENUM) {
         int enum_val = -1;
         PyC_FlagSet *items = (PyC_FlagSet *)slot->data.enum_data.flags;
-        const char *enum_str = _PyUnicode_AsString(value);
+        const char *enum_str = PyUnicode_AsUTF8(value);
 
         if (enum_str == NULL) {
           PyErr_Format(PyExc_TypeError,
@@ -787,7 +787,7 @@ PyObject *BPy_BMO_call(BPy_BMeshOpFunc *self, PyObject *args, PyObject *kw)
     PyObject *key, *value;
     Py_ssize_t pos = 0;
     while (PyDict_Next(kw, &pos, &key, &value)) {
-      const char *slot_name = _PyUnicode_AsString(key);
+      const char *slot_name = PyUnicode_AsUTF8(key);
       BMOpSlot *slot;
 
       if (!BMO_slot_exists(bmop.slots_in, slot_name)) {
diff --git a/source/blender/python/bmesh/bmesh_py_types_customdata.c b/source/blender/python/bmesh/bmesh_py_types_customdata.c
index 96c36f2d7884..471a311c4114 100644
--- a/source/blender/python/bmesh/bmesh_py_types_customdata.c
+++ b/source/blender/python/bmesh/bmesh_py_types_customdata.c
@@ -804,7 +804,7 @@ static PyObject *bpy_bmlayercollection_subscript(BPy_BMLayerCollection *self, Py
 {
   /* don't need error check here */
   if (PyUnicode_Check(key)) {
-    return bpy_bmlayercollection_subscript_str(self, _PyUnicode_AsString(key));
+    return bpy_bmlayercollection_subscript_str(self, PyUnicode_AsUTF8(key));
   }
   if (PyIndex_Check(key)) {
     const Py_ssize_t i = PyNumber_AsSsize_t(key, PyExc_IndexError);
@@ -862,7 +862,7 @@ static PyObject *bpy_bmlayercollection_subscript(BPy_BMLayerCollection *self, Py
 
 static int bpy_bmlayercollection_contains(BPy_BMLayerCollection *self, PyObject *value)
 {
-  const char *keyname = _PyUnicode_AsString(value);
+  const char *keyname = PyUnicode_AsUTF8(value);
   CustomData *data;
   int index;
 
diff --git a/source/blender/python/generic/idprop_py_api.c b/source/blender/python/generic/idprop_py_api.c
index 6be7348a2f8a..c329ea7965c3 100644
--- a/source/blender/python/generic/idprop_py_api.c
+++ b/source/blender/python/generic/idprop_py_api.c
@@ -189,13 +189,13 @@ static int BPy_IDGroup_SetData(BPy_IDProperty *self, IDProperty *prop, PyObject
         st = (char *)PyC_UnicodeAsByte(value, &value_coerce);
         alloc_len = strlen(st) + 1;
 
-        st = _PyUnicode_AsString(value);
+        st = PyUnicode_AsUTF8(value);
         IDP_ResizeArray(prop, alloc_len);
         memcpy(IDP_Array(prop), st, alloc_len);
         Py_XDECREF(value_coerce);
       }
 #  else
-      st = _PyUnicode_AsString(value);
+      st = PyUnicode_AsUTF8(value);
       IDP_ResizeArray(prop, strlen(st) + 1);
       strcpy(IDP_Array(prop), st);
 #  endif
@@ -253,7 +253,7 @@ static int BPy_IDGroup_SetName(BPy_IDProperty *self, PyObject *value, void *UNUS
     return -1;
   }
 
-  name = _PyUnicode_AsStringAndSize(value, &name_size);
+  name = PyUnicode_AsUTF8AndSize(value, &name_size);
 
   if (name_size >= MAX_IDPROP_NAME) {
     PyErr_SetString(PyExc_TypeError, "string length cannot exceed 63 characters!");
@@ -300,7 +300,7 @@ static PyObject *BPy_IDGroup_Map_GetItem(BPy_IDProperty *self, PyObject *item)
     return NULL;
   }
 
-  name = _PyUnicode_AsString(item);
+  name = PyUnicode_AsUTF8(item);
 
   if (name == NULL) {
     PyErr_SetString(PyExc_TypeError, "only strings are allowed as keys of ID properties");
@@ -358,7 +358,7 @@ static const char *idp_try_read_name(PyObject *name_obj)
   const char *name = NULL;
   if (name_obj) {
     Py_ssize_t name_size;
-    name = _PyUnicode_AsStringAndSize(name_obj, &name_size);
+    name = PyUnicode_AsUTF8AndSize(name_obj, &name_size);
 
     if (name == NULL) {
       PyErr_Format(PyExc_KeyError,
@@ -420,7 +420,7 @@ static IDProperty *idp_from_PyUnicode(const char *name, PyObject *ob)
   prop = IDP_New(IDP_STRING, &val, name);
   Py_XDECREF(value_coerce);
 #else
-  val.str = _PyUnicode_AsString(ob);
+  val.str = PyUnicode_AsUTF8(ob);
   prop = IDP_New(IDP_STRING, val, name);
 #endif
   return prop;
@@ -722,7 +722,7 @@ int BPy_Wrap_SetMapItem(IDProperty *prop, PyObject *key, PyObject *val)
 
   if (val == NULL) { /* del idprop[key] */
     IDProperty *pkey;
-    const char *name = _PyUnicode_AsString(key);
+    const char *name = PyUnicode_AsUTF8(key);
 
     if (name == NULL) {
       PyErr_Format(PyExc_KeyError, "expected a string, not %.200s", Py_TYPE(key)->tp_name);
@@ -1050,7 +1050,7 @@ static PyObject *BPy_IDGroup_items(BPy_IDProperty *self)
 
 static int BPy_IDGroup_Contains(BPy_IDProperty *self, PyObject *value)
 {
-  const char *name = _PyUnicode_AsString(value);
+  const char *name = PyUnicode_AsUTF8(value);
 
   if (!name) {
     PyErr_Format(PyExc_TypeError, "expected a string, not a %.200s", Py_TYPE(value)->tp_name);
diff --git a/source/blender/python/generic/imbuf_py_api.c b/source/blender/python/generic/imbuf_py_api.c
index d05690759ceb..fe72f267a5d0 100644
--- a/source/blender/python/generic/imbuf_py_api.c
+++ b/source/blender/python/generic/imbuf_py_api.c
@@ -267,7 +267,7 @@ static int py_imbuf_filepath_set(Py_ImBuf *self, PyObject *value, void *UNUSED(c
   ImBuf *ibuf = self->ibuf;
   const Py_ssize_t value_str_len_max = sizeof(ibuf->name);
   Py_ssize_t value_str_len;
-  const char *value_str = _PyUnicode_AsStringAndSize(value, &value_str_len);
+  const char *value_str = PyUnicode_AsUTF8AndSize(value, &value_str_len);
   if (value_str_len >= value_str_len_max) {
     PyErr_Format(PyExc_TypeError, "filepath length over %zd", value_str_len_max - 1);
     return -1;
diff --git a/source/blender/python/generic/py_capi_utils.c b/source/blender/python/generic/py_capi_utils.c
index 1eb4a51c3923..c7ce264f2f93 100644
--- a/source/blender/python/generic/py_capi_utils.c
+++ b/source/blender/python/generic/py_capi_utils.c
@@ -257,7 +257,7 @@ int PyC_ParseBool(PyObject *o, void *p)
 int PyC_ParseStringEnum(PyObject *o, void *p)
 {
   struct PyC_StringEnum *e = p;
-  const char *value = _PyUnicode_AsString(o);
+  const char *value = PyUnicode_AsUTF8(o);
   if (value == NULL) {
     PyErr_Format(PyExc_ValueError, "expected a string, got %s", Py_TYPE(o)->tp_name);
     return 0;
@@ -343,7 +343,7 @@ void PyC_ObSpitStr(char *result, size_t result_len, PyObject *var)
                  (int)var->ob_refcnt,
                  (void *)var,
                  type ? type->tp_name : null_str,
-                 var_str ? _PyUnicode_AsString(var_str) : "<error>");
+                 var_str ? PyUnicode_AsUTF8(var_str) : "<error>");
     if (var_str != NULL) {
       Py_DECREF(var_str);
     }
@@ -405,7 +405,7 @@ void PyC_FileAndNum(const char **r_filename, int *r_lineno)
 
   /* when executing a script */
   if (r_filename) {
-    *r_filename = _PyUnicode_AsString(frame->f_code->co_filename);
+    *r_filename = PyUnicode_AsUTF8(frame->f_code->co_filename);
   }
 
   /* when executing a module */
@@ -418,7 +418,7 @@ void PyC_FileAndNum(const char **r_filename, int *r_lineno)
       if (mod) {
         PyObject *mod_file = PyModule_GetFilenameObject(mod);
         if (mod_file) {
-          *r_filename = _PyUnicode_AsString(mod_name);
+          *r_filename = PyUnicode_AsUTF8(mod_name);
           Py_DECREF(mod_file);
         }
         else {
@@ -428,7 +428,7 @@ void PyC_FileAndNum(const char **r_filename, int *r_lineno)
 
       /* unlikely, fallback */
       if (*r_filename == NULL) {
-        *r_filename = _PyUnicode_AsString(mod_name);
+        *r_filename = PyUnicode_AsUTF8(mod_name);
       }
     }
   }
@@ -569,9 +569,9 @@ void PyC_Err_PrintWithFunc(PyObject *py_func)
   /* use py style error */
   fprintf(stderr,
           "File \"%s\", line %d, in %s\n",
-          _PyUnicode_AsString(f_code->co_filename),
+          PyUnicode_AsUTF8(f_code->co_filename),
           f_code->co_firstlineno,
-          _PyUnicode_AsString(((PyFunctionObject *)py_func)->func_name));
+          PyUnicode_AsUTF8(((PyFunctionObject *)py_func)->func_name));
 }
 
 /** \} */
@@ -740,7 +740,7 @@ const char *PyC_UnicodeAsByteAndSize(PyObject *py_str, Py_ssize_t *size, PyObjec
 {
   const char *result;
 
-  result = _PyUnicode_AsStringAndSize(py_str, size);
+  result = PyUnicode_AsUTF8AndSize(py_str, size);
 
   if (result) {
     /* 99% of the time this is enough but we better support non unicode
@@ -767,7 +767,7 @@ const char *PyC_UnicodeAsByte(PyObject *py_str, PyObject **coerce)
 {
   const char *result;
 
-  result = _PyUnicode_AsString(py_str);
+  result = PyUnicode_AsUTF8(py_str);
 
   if (result) {
     /* 99% of the time this is enough but we better support non unicode
@@ -1146,7 +1146,7 @@ int PyC_FlagSet_ToBitfield(PyC_FlagSet *items,
   *r_value = 0;
 
   while (_PySet_NextEntry(value, &pos, &key, &hash)) {
-    const char *param = _PyUnicode_AsString(key);
+    const char *param = PyUnicode_AsUTF8(key);
 
     if (param == NULL) {
       PyErr_Format(PyExc_TypeError,
@@ -1324,7 +1324,7 @@ bool PyC_RunString_AsStringAndSize(const char *imports[],
     const char *val;
     Py_ssize_t val_len;
 
-    val = _PyUnicode_AsStringAndSize(retval, &val_len);
+    val = PyUnicode_AsUTF8AndSize(retval, &val_len);
     if (val == NULL && PyErr_Occurred()) {
       ok = false;
     }
diff --git a/source/blender/python/gpu/gpu_py_api.c b/source/blender/python/gpu/gpu_py_api.c
index 954118ffa5f1..eb2fd1f73045 100644
--- a/source/blender/python/gpu/gpu_py_api.c
+++ b/source/blender/python/gpu/gpu_py_api.c
@@ -64,7 +64,7 @@ bool bpygpu_is_init_or_error(void)
 int bpygpu_ParsePrimType(PyObject *o, void *p)
 {
   Py_ssize_t mode_id_len;
-  const char *mode_id = _PyUnicode_AsStringAndSize(o, &mode_id_len);
+  const char *mode_id = PyUnicode_AsUTF8AndSize(o, &mode_id_len);
   if (mode_id == NULL) {
     PyErr_Format(PyExc_ValueError, "expected a string, got %s", Py_TYPE(o)->tp_name);
     return 0;
diff --git a/source/blender/python/gpu/gpu_py_vertex_format.c b/source/blender/python/gpu/gpu_py_vertex_format.c
index 7d1e4ee4868c..52e1a720f970 100644
--- a/source/blender/python/gpu/gpu_py_vertex_format.c
+++ b/source/blender/python/gpu/gpu_py_vertex_format.c
@@ -105,7 +105,7 @@ static int py_parse_fetch_mode(const char *str, int length)
 static int py_ParseVertCompType(PyObject *o, void *p)
 {
   Py_ssize_t length;
-  const char *str = _PyUnicode_AsStringAndSize(o, &length);
+  const char *str = PyUnicode_AsUTF8AndSize(o, &length);
 
   if (str == NULL) {
     PyErr_Format(PyExc_ValueError, "expected a string, got %s", Py_TYPE(o)->tp_name);
@@ -125,7 +125,7 @@ static int py_ParseVertCompType(PyObject *o, void *p)
 static int py_ParseVertFetchMode(PyObject *o, void *p)
 {
   Py_ssize_t length;
-  const char *str = _PyUnicode_AsStringAndSize(o, &length);
+  const char *str = PyUnicode_AsUTF8AndSize(o, &length);
 
   if (str == NULL) {
     PyErr_Format(PyExc_ValueError, "expected a string, got %s", Py_TYPE(o)->tp_name);
diff --git a/source/blender/python/intern/bpy.c b/source/blender/python/intern/bpy.c
index 6462f8320d77..74fc8bcfec9e 100644
--- a/source/blender/python/intern/bpy.c
+++ b/source/blender/python/intern/bpy.c
@@ -261,7 +261,7 @@ PyDoc_STRVAR(bpy_escape_identifier_doc,
 static PyObject *bpy_escape_identifier(PyObject *UNUSED(self), PyObject *value)
 {
   Py_ssize_t value_str_len;
-  const char *value_str = _PyUnicode_AsStringAndSize(value, &value_str_len);
+  const char *value_str = PyUnicode_AsUTF8AndSize(value, &value_str_len);
 
   if (value_str == NULL) {
     PyErr_SetString(PyExc_TypeError, "expected a string");
@@ -299,7 +299,7 @@ PyDoc_STRVAR(bpy_unescape_identifier_doc,
 static PyObject *bpy_unescape_identifier(PyObject *UNUSED(self), PyObject *value)
 {
   Py_ssize_t value_str_len;
-  const char *value_str = _PyUnicode_AsStringAndSize(value, &value_str_len);
+  const char *value_str = PyUnicode_AsUTF8AndSize(value, &value_str_len);
 
   if (value_str == NULL) {
     PyErr_SetString(PyExc_TypeError, "expected a string");
diff --git a/source/blender/python/intern/bpy_app_translations.c b/source/blender/python/intern/bpy_app_translations.c
index 56fc3efc0902..d00f205ddc0f 100644
--- a/source/blender/python/intern/bpy_app_translations.c
+++ b/source/blender/python/intern/bpy_app_translations.c
@@ -211,7 +211,7 @@ static void _build_translations_cache(PyObject *py_messages, const char *locale)
             msgctxt = BLT_I18NCONTEXT_DEFAULT_BPYRNA;
           }
           else if (PyUnicode_Check(tmp)) {
-            msgctxt = _PyUnicode_AsString(tmp);
+            msgctxt = PyUnicode_AsUTF8(tmp);
           }
           else {
             invalid_key = true;
@@ -219,7 +219,7 @@ static void _build_translations_cache(PyObject *py_messages, const char *locale)
 
           tmp = PyTuple_GET_ITEM(pykey, 1);
           if (PyUnicode_Check(tmp)) {
-            msgid = _PyUnicode_AsString(tmp);
+            msgid = PyUnicode_AsUTF8(tmp);
           }
           else {
             invalid_key = true;
@@ -250,7 +250,7 @@ static void _build_translations_cache(PyObject *py_messages, const char *locale)
         /* Do not overwrite existing keys! */
         if (BPY_app_translations_py_pgettext(msgctxt, msgid) == msgid) {
           GHashKey *key = _ghashutil_keyalloc(msgctxt, msgid);
-          BLI_ghash_insert(_translations_cache, key, BLI_strdup(_PyUnicode_AsString(trans)));
+          BLI_ghash_insert(_translations_cache, key, BLI_strdup(PyUnicode_AsUTF8(trans)));
         }
       }
     }
@@ -341,7 +341,7 @@ static PyObject *app_translations_py_messages_register(BlenderAppTranslations *s
         PyExc_ValueError,
         "bpy.app.translations.register: translations message cache already contains some data for "
         "addon '%s'",
-        (const char *)_PyUnicode_AsString(module_name));
+        (const char *)PyUnicode_AsUTF8(module_name));
     return NULL;
   }
 
diff --git a/source/blender/python/intern/bpy_capi_utils.c b/source/blender/python/intern/bpy_capi_utils.c
index 57dc4c0a6791..b2670161d92a 100644
--- a/source/blender/python/intern/bpy_capi_utils.c
+++ b/source/blender/python/intern/bpy_capi_utils.c
@@ -136,7 +136,7 @@ bool BPy_errors_to_report_ex(ReportList *reports,
                 RPT_ERROR,
                 TIP_("%s: %s\nlocation: %s:%d\n"),
                 error_prefix,
-                _PyUnicode_AsString(pystring),
+                PyUnicode_AsUTF8(pystring),
                 filename,
                 lineno);
 
@@ -144,12 +144,12 @@ bool BPy_errors_to_report_ex(ReportList *reports,
     fprintf(stderr,
             TIP_("%s: %s\nlocation: %s:%d\n"),
             error_prefix,
-            _PyUnicode_AsString(pystring),
+            PyUnicode_AsUTF8(pystring),
             filename,
             lineno);
   }
   else {
-    BKE_reportf(reports, RPT_ERROR, "%s: %s", error_prefix, _PyUnicode_AsString(pystring));
+    BKE_reportf(reports, RPT_ERROR, "%s: %s", error_prefix, PyUnicode_AsUTF8(pystring));
   }
 
   Py_DECREF(pystring);
diff --git a/source/blender/python/intern/bpy_driver.c b/source/blender/python/intern/bpy_driver.c
index c0536693f389..5102aa17250f 100644
--- a/source/blender/python/intern/bpy_driver.c
+++ b/source/blender/python/intern/bpy_driver.c
@@ -163,7 +163,7 @@ int bpy_pydriver_create_dict(void)
       PyObject *arg_key, *arg_value;
       Py_ssize_t arg_pos = 0;
       while (PyDict_Next(mod_math_dict, &arg_pos, &arg_key, &arg_value)) {
-        const char *arg_str = _PyUnicode_AsString(arg_key);
+        const char *arg_str = PyUnicode_AsUTF8(arg_key);
         if (arg_str[0] && arg_str[1] != '_') {
           PyDict_SetItem(bpy_pydriver_Dict__whitelist, arg_key, Py_None);
         }
@@ -363,7 +363,7 @@ static bool bpy_driver_secure_bytecode_validate(PyObject *expr_code, PyObject *d
         fprintf(stderr,
                 "\tBPY_driver_eval() - restricted access disallows name '%s', "
                 "enable auto-execution to support\n",
-                _PyUnicode_AsString(name));
+                PyUnicode_AsUTF8(name));
         return false;
       }
     }
diff --git a/source/blender/python/intern/bpy_interface.c b/source/blender/python/intern/bpy_interface.c
index 311612e14999..9fea65935e13 100644
--- a/source/blender/python/intern/bpy_interface.c
+++ b/source/blender/python/intern/bpy_interface.c
@@ -585,8 +585,8 @@ void BPY_python_backtrace(FILE *fp)
     PyFrameObject *frame = tstate->frame;
     do {
       const int line = PyCode_Addr2Line(frame->f_code, frame->f_lasti);
-      const char *filename = _PyUnicode_AsString(frame->f_code->co_filename);
-      const char *funcname = _PyUnicode_AsString(frame->f_code->co_name);
+      const char *filename = PyUnicode_AsUTF8(frame->f_code->co_filename);
+      const char *funcname = PyUnicode_AsUTF8(frame->f_code->co_name);
       fprintf(fp, "  File \"%s\", line %d in %s\n", filename, line, funcname);
     } while ((frame = frame->f_back));
   }
@@ -778,7 +778,7 @@ static void bpy_module_delay_init(PyObject *bpy_proxy)
   /* updating the module dict below will lose the reference to __file__ */
   PyObject *filename_obj = PyModule_GetFilenameObject(bpy_proxy);
 
-  const char *filename_rel = _PyUnicode_AsString(filename_obj); /* can be relative */
+  const char *filename_rel = PyUnicode_AsUTF8(filename_obj); /* can be relative */
   char filename_abs[1024];
 
   BLI_strncpy(filename_abs, filename_rel, sizeof(filename_abs));
diff --git a/source/blender/python/intern/bpy_library_load.c b/source/blender/python/intern/bpy_library_load.c
index 7ee563feff8b..020c8f7ea494 100644
--- a/source/blender/python/intern/bpy_library_load.c
+++ b/source/blender/python/intern/bpy_library_load.c
@@ -361,7 +361,7 @@ static PyObject *bpy_lib_exit(BPy_Library *self, PyObject *UNUSED(args))
           for (i = 0; i < size; i++) {
             PyObject *item_src = PyList_GET_ITEM(ls, i);
             PyObject *item_dst; /* must be set below */
-            const char *item_idname = _PyUnicode_AsString(item_src);
+            const char *item_idname = PyUnicode_AsUTF8(item_src);
 
             // printf("  %s\n", item_idname);
 
diff --git a/source/blender/python/intern/bpy_msgbus.c b/source/blender/python/intern/bpy_msgbus.c
index df45007b68fd..7cc7f864c9c4 100644
--- a/source/blender/python/intern/bpy_msgbus.c
+++ b/source/blender/python/intern/bpy_msgbus.c
@@ -118,7 +118,7 @@ static int py_msgbus_rna_key_from_py(PyObject *py_sub,
       PointerRNA data_type_ptr = {
           .type = data_type,
       };
-      const char *data_prop_str = _PyUnicode_AsString(data_prop_py);
+      const char *data_prop_str = PyUnicode_AsUTF8(data_prop_py);
       PropertyRNA *data_prop = RNA_struct_find_property(&data_type_ptr, data_prop_str);
 
       if (data_prop == NULL) {
diff --git a/source/blender/python/intern/bpy_operator.c b/source/blender/python/intern/bpy_operator.c
index 5ac76ab9ac11..967eece4bcbf 100644
--- a/source/blender/python/intern/bpy_operator.c
+++ b/source/blender/python/intern/bpy_operator.c
@@ -58,7 +58,7 @@
 
 static wmOperatorType *ot_lookup_from_py_string(PyObject *value, const char *py_fn_id)
 {
-  const char *opname = _PyUnicode_AsString(value);
+  const char *opname = PyUnicode_AsUTF8(value);
   if (opname == NULL) {
     PyErr_Format(PyExc_TypeError, "%s() expects a string argument", py_fn_id);
     return NULL;
diff --git a/source/blender/python/intern/bpy_operator_wrap.c b/source/blender/python/intern/bpy_operator_wrap.c
index 9fb25d418449..5137f41d43a0 100644
--- a/source/blender/python/intern/bpy_operator_wrap.c
+++ b/source/blender/python/intern/bpy_operator_wrap.c
@@ -68,7 +68,7 @@ static void operator_properties_init(wmOperatorType *ot)
     if (bl_property) {
       if (PyUnicode_Check(bl_property)) {
         /* since the property is explicitly given, raise an error if its not found */
-        prop_id = _PyUnicode_AsString(bl_property);
+        prop_id = PyUnicode_AsUTF8(bl_property);
         prop_raise_error = true;
       }
       else {
diff --git a/source/blender/python/intern/bpy_props.c b/source/blender/python/intern/bpy_props.c
index 354086ef4c38..878bf4aec5dc 100644
--- a/source/blender/python/intern/bpy_props.c
+++ b/source/blender/python/intern/bpy_props.c
@@ -1152,7 +1152,7 @@ static void bpy_prop_string_get_cb(struct PointerRNA *ptr, struct PropertyRNA *p
   }
   else {
     Py_ssize_t length;
-    const char *buffer = _PyUnicode_AsStringAndSize(ret, &length);
+    const char *buffer = PyUnicode_AsUTF8AndSize(ret, &length);
     memcpy(value, buffer, length + 1);
     Py_DECREF(ret);
   }
@@ -1213,7 +1213,7 @@ static int bpy_prop_string_length_cb(struct PointerRNA *ptr, struct PropertyRNA
   }
   else {
     Py_ssize_t length_ssize_t = 0;
-    _PyUnicode_AsStringAndSize(ret, &length_ssize_t);
+    PyUnicode_AsUTF8AndSize(ret, &length_ssize_t);
     length = length_ssize_t;
     Py_DECREF(ret);
   }
@@ -1488,7 +1488,7 @@ static const EnumPropertyItem *enum_items_from_py(PyObject *seq_fast,
   else {
     if (def) {
       if (!py_long_as_int(def, &def_int_cmp)) {
-        def_string_cmp = _PyUnicode_AsString(def);
+        def_string_cmp = PyUnicode_AsUTF8(def);
         if (def_string_cmp == NULL) {
           PyErr_Format(PyExc_TypeError,
                        "EnumProperty(...): default option must be a 'str' or 'int' "
@@ -1517,14 +1517,13 @@ static const EnumPropertyItem *enum_items_from_py(PyObject *seq_fast,
 
     if ((PyTuple_CheckExact(item)) && (item_size = PyTuple_GET_SIZE(item)) &&
         (item_size >= 3 && item_size <= 5) &&
-        (tmp.identifier = _PyUnicode_AsStringAndSize(PyTuple_GET_ITEM(item, 0), &id_str_size)) &&
-        (tmp.name = _PyUnicode_AsStringAndSize(PyTuple_GET_ITEM(item, 1), &name_str_size)) &&
-        (tmp.description = _PyUnicode_AsStringAndSize(PyTuple_GET_ITEM(item, 2),
-                                                      &desc_str_size)) &&
+        (tmp.identifier = PyUnicode_AsUTF8AndSize(PyTuple_GET_ITEM(item, 0), &id_str_size)) &&
+        (tmp.name = PyUnicode_AsUTF8AndSize(PyTuple_GET_ITEM(item, 1), &name_str_size)) &&
+        (tmp.description = PyUnicode_AsUTF8AndSize(PyTuple_GET_ITEM(item, 2), &desc_str_size)) &&
         /* TODO, number isn't ensured to be unique from the script author */
         (item_size != 4 || py_long_as_int(PyTuple_GET_ITEM(item, 3), &tmp.value)) &&
         (item_size != 5 || ((py_long_as_int(PyTuple_GET_ITEM(item, 3), &tmp.icon) ||
-                             (tmp_icon = _PyUnicode_AsString(PyTuple_GET_ITEM(item, 3)))) &&
+                             (tmp_icon = PyUnicode_AsUTF8(PyTuple_GET_ITEM(item, 3)))) &&
                             py_long_as_int(PyTuple_GET_ITEM(item, 4), &tmp.value)))) {
       if (is_enum_flag) {
         if (item_size < 4) {
@@ -3301,7 +3300,7 @@ StructRNA *pointer_type_from_py(PyObject *value, const char *error_prefix)
   if (!srna) {
     if (PyErr_Occurred()) {
       PyObject *msg = PyC_ExceptionBuffer();
-      const char *msg_char = _PyUnicode_AsString(msg);
+      const char *msg_char = PyUnicode_AsUTF8(msg);
       PyErr_Format(
           PyExc_TypeError, "%.200s expected an RNA type, failed with: %s", error_prefix, msg_char);
       Py_DECREF(msg);
diff --git a/source/blender/python/intern/bpy_rna.c b/source/blender/python/intern/bpy_rna.c
index 0b1af733f846..c0f3ba30d93c 100644
--- a/source/blender/python/intern/bpy_rna.c
+++ b/source/blender/python/intern/bpy_rna.c
@@ -323,7 +323,7 @@ static bool rna_id_write_error(PointerRNA *ptr, PyObject *key)
       const char *idtype = BKE_idtype_idcode_to_name(idcode);
       const char *pyname;
       if (key && PyUnicode_Check(key)) {
-        pyname = _PyUnicode_AsString(key);
+        pyname = PyUnicode_AsUTF8(key);
       }
       else {
         pyname = "<UNKNOWN>";
@@ -1252,7 +1252,7 @@ static const char *pyrna_enum_as_string(PointerRNA *ptr, PropertyRNA *prop)
 static int pyrna_string_to_enum(
     PyObject *item, PointerRNA *ptr, PropertyRNA *prop, int *r_value, const char *error_prefix)
 {
-  const char *param = _PyUnicode_AsString(item);
+  const char *param = PyUnicode_AsUTF8(item);
 
   if (param == NULL) {
     PyErr_Format(PyExc_TypeError,
@@ -1299,7 +1299,7 @@ BLI_bitmap *pyrna_set_to_enum_bitmap(const EnumPropertyItem *items,
   BLI_bitmap *bitmap = BLI_BITMAP_NEW(bitmap_size, __func__);
 
   while (_PySet_NextEntry(value, &pos, &key, &hash)) {
-    const char *param = _PyUnicode_AsString(key);
+    const char *param = PyUnicode_AsUTF8(key);
     if (param == NULL) {
       PyErr_Format(PyExc_TypeError,
                    "%.200s expected a string, not %.200s",
@@ -1364,7 +1364,7 @@ int pyrna_set_to_enum_bitfield(const EnumPropertyItem *items,
   *r_value = 0;
 
   while (_PySet_NextEntry(value, &pos, &key, &hash)) {
-    const char *param = _PyUnicode_AsString(key);
+    const char *param = PyUnicode_AsUTF8(key);
 
     if (param == NULL) {
       PyErr_Format(PyExc_TypeError,
@@ -1662,7 +1662,7 @@ int pyrna_pydict_to_props(PointerRNA *ptr,
     Py_ssize_t pos = 0;
 
     while (PyDict_Next(kw, &pos, &key, &value)) {
-      arg_name = _PyUnicode_AsString(key);
+      arg_name = PyUnicode_AsUTF8(key);
       if (RNA_struct_find_property(ptr, arg_name) == NULL) {
         break;
       }
@@ -1871,10 +1871,10 @@ static int pyrna_py_to_prop(
             param = PyC_UnicodeAsByte(value, &value_coerce);
           }
           else {
-            param = _PyUnicode_AsString(value);
+            param = PyUnicode_AsUTF8(value);
           }
 #else  /* USE_STRING_COERCE */
-          param = _PyUnicode_AsString(value);
+          param = PyUnicode_AsUTF8(value);
 #endif /* USE_STRING_COERCE */
 
           if (param == NULL) {
@@ -2186,7 +2186,7 @@ static int pyrna_py_to_prop(
           if (pyrna_pydict_to_props(
                   &itemptr, item, true, "Converting a Python list to an RNA collection") == -1) {
             PyObject *msg = PyC_ExceptionBuffer();
-            const char *msg_char = _PyUnicode_AsString(msg);
+            const char *msg_char = PyUnicode_AsUTF8(msg);
 
             PyErr_Format(PyExc_TypeError,
                          "%.200s %.200s.%.200s error converting a member of a collection "
@@ -2490,7 +2490,7 @@ static int pyrna_prop_collection_subscript_str_lib_pair_ptr(BPy_PropertyRNA *sel
                  RNA_struct_identifier(self->ptr.type));
     return -1;
   }
-  if ((keyname = _PyUnicode_AsString(PyTuple_GET_ITEM(key, 0))) == NULL) {
+  if ((keyname = PyUnicode_AsUTF8(PyTuple_GET_ITEM(key, 0))) == NULL) {
     PyErr_Format(PyExc_KeyError,
                  "%s: id must be a string, not %.200s",
                  err_prefix,
@@ -2507,7 +2507,7 @@ static int pyrna_prop_collection_subscript_str_lib_pair_ptr(BPy_PropertyRNA *sel
   }
   else if (PyUnicode_Check(keylib)) {
     Main *bmain = self->ptr.data;
-    const char *keylib_str = _PyUnicode_AsString(keylib);
+    const char *keylib_str = PyUnicode_AsUTF8(keylib);
     lib = BLI_findstring(&bmain->libraries, keylib_str, offsetof(Library, filepath));
     if (lib == NULL) {
       if (err_not_found) {
@@ -2711,7 +2711,7 @@ static PyObject *pyrna_prop_collection_subscript(BPy_PropertyRNA *self, PyObject
   PYRNA_PROP_CHECK_OBJ(self);
 
   if (PyUnicode_Check(key)) {
-    return pyrna_prop_collection_subscript_str(self, _PyUnicode_AsString(key));
+    return pyrna_prop_collection_subscript_str(self, PyUnicode_AsUTF8(key));
   }
   if (PyIndex_Check(key)) {
     const Py_ssize_t i = PyNumber_AsSsize_t(key, PyExc_IndexError);
@@ -2838,7 +2838,7 @@ static int pyrna_prop_collection_ass_subscript(BPy_PropertyRNA *self,
 
 #if 0
   if (PyUnicode_Check(key)) {
-    return pyrna_prop_collection_subscript_str(self, _PyUnicode_AsString(key));
+    return pyrna_prop_collection_subscript_str(self, PyUnicode_AsUTF8(key));
   }
   else
 #endif
@@ -2910,7 +2910,7 @@ static PyObject *pyrna_prop_array_subscript(BPy_PropertyArrayRNA *self, PyObject
 
 #if 0
   if (PyUnicode_Check(key)) {
-    return pyrna_prop_array_subscript_str(self, _PyUnicode_AsString(key));
+    return pyrna_prop_array_subscript_str(self, PyUnicode_AsUTF8(key));
   }
   else
 #endif
@@ -3359,7 +3359,7 @@ static int pyrna_prop_collection_contains(BPy_PropertyRNA *self, PyObject *key)
   }
 
   /* Key in dict style check. */
-  const char *keyname = _PyUnicode_AsString(key);
+  const char *keyname = PyUnicode_AsUTF8(key);
 
   if (keyname == NULL) {
     PyErr_SetString(PyExc_TypeError,
@@ -3377,7 +3377,7 @@ static int pyrna_prop_collection_contains(BPy_PropertyRNA *self, PyObject *key)
 static int pyrna_struct_contains(BPy_StructRNA *self, PyObject *value)
 {
   IDProperty *group;
-  const char *name = _PyUnicode_AsString(value);
+  const char *name = PyUnicode_AsUTF8(value);
 
   PYRNA_STRUCT_CHECK_INT(self);
 
@@ -3447,7 +3447,7 @@ static PyObject *pyrna_struct_subscript(BPy_StructRNA *self, PyObject *key)
 {
   /* Mostly copied from BPy_IDGroup_Map_GetItem. */
   IDProperty *group, *idprop;
-  const char *name = _PyUnicode_AsString(key);
+  const char *name = PyUnicode_AsUTF8(key);
 
   PYRNA_STRUCT_CHECK_OBJ(self);
 
@@ -4231,7 +4231,7 @@ static PyObject *pyrna_struct_dir(BPy_StructRNA *self)
 /* ---------------getattr-------------------------------------------- */
 static PyObject *pyrna_struct_getattro(BPy_StructRNA *self, PyObject *pyname)
 {
-  const char *name = _PyUnicode_AsString(pyname);
+  const char *name = PyUnicode_AsUTF8(pyname);
   PyObject *ret;
   PropertyRNA *prop;
   FunctionRNA *func;
@@ -4378,7 +4378,7 @@ static PyObject *pyrna_struct_meta_idprop_getattro(PyObject *cls, PyObject *attr
   if ((ret == NULL)  /* || pyrna_is_deferred_prop(ret) */ ) {
     StructRNA *srna = srna_from_self(cls, "StructRNA.__getattr__");
     if (srna) {
-      PropertyRNA *prop = RNA_struct_type_find_property(srna, _PyUnicode_AsString(attr));
+      PropertyRNA *prop = RNA_struct_type_find_property(srna, PyUnicode_AsUTF8(attr));
       if (prop) {
         PointerRNA tptr;
         PyErr_Clear(); /* Clear error from tp_getattro. */
@@ -4397,7 +4397,7 @@ static int pyrna_struct_meta_idprop_setattro(PyObject *cls, PyObject *attr, PyOb
 {
   StructRNA *srna = srna_from_self(cls, "StructRNA.__setattr__");
   const bool is_deferred_prop = (value && pyrna_is_deferred_prop(value));
-  const char *attr_str = _PyUnicode_AsString(attr);
+  const char *attr_str = PyUnicode_AsUTF8(attr);
 
   if (srna && !pyrna_write_check() &&
       (is_deferred_prop || RNA_struct_type_find_property(srna, attr_str))) {
@@ -4458,7 +4458,7 @@ static int pyrna_struct_meta_idprop_setattro(PyObject *cls, PyObject *attr, PyOb
 
 static int pyrna_struct_setattro(BPy_StructRNA *self, PyObject *pyname, PyObject *value)
 {
-  const char *name = _PyUnicode_AsString(pyname);
+  const char *name = PyUnicode_AsUTF8(pyname);
   PropertyRNA *prop = NULL;
 
   PYRNA_STRUCT_CHECK_INT(self);
@@ -4550,7 +4550,7 @@ static PyObject *pyrna_prop_array_getattro(BPy_PropertyRNA *self, PyObject *pyna
 
 static PyObject *pyrna_prop_collection_getattro(BPy_PropertyRNA *self, PyObject *pyname)
 {
-  const char *name = _PyUnicode_AsString(pyname);
+  const char *name = PyUnicode_AsUTF8(pyname);
 
   if (name == NULL) {
     PyErr_SetString(PyExc_AttributeError, "bpy_prop_collection: __getattr__ must be a string");
@@ -4618,7 +4618,7 @@ static PyObject *pyrna_prop_collection_getattro(BPy_PropertyRNA *self, PyObject
 /* --------------- setattr------------------------------------------- */
 static int pyrna_prop_collection_setattro(BPy_PropertyRNA *self, PyObject *pyname, PyObject *value)
 {
-  const char *name = _PyUnicode_AsString(pyname);
+  const char *name = PyUnicode_AsUTF8(pyname);
   PropertyRNA *prop;
   PointerRNA r_ptr;
 
@@ -5015,7 +5015,7 @@ static PyObject *pyrna_prop_collection_get(BPy_PropertyRNA *self, PyObject *args
   }
 
   if (PyUnicode_Check(key_ob)) {
-    const char *key = _PyUnicode_AsString(key_ob);
+    const char *key = PyUnicode_AsUTF8(key_ob);
 
     if (RNA_property_collection_lookup_string(&self->ptr, self->prop, key, &newptr)) {
       return pyrna_struct_CreatePyObject(&newptr);
@@ -5050,7 +5050,7 @@ PyDoc_STRVAR(pyrna_prop_collection_find_doc,
 static PyObject *pyrna_prop_collection_find(BPy_PropertyRNA *self, PyObject *key_ob)
 {
   Py_ssize_t key_len_ssize_t;
-  const char *key = _PyUnicode_AsStringAndSize(key_ob, &key_len_ssize_t);
+  const char *key = PyUnicode_AsUTF8AndSize(key_ob, &key_len_ssize_t);
   const int key_len = (int)key_len_ssize_t; /* Comare with same type. */
 
   char name[256], *nameptr;
@@ -6035,7 +6035,7 @@ static PyObject *small_dict_get_item_string(PyObject *dict, const char *key_look
 
   while (PyDict_Next(dict, &pos, &key, &value)) {
     if (PyUnicode_Check(key)) {
-      if (STREQ(key_lookup, _PyUnicode_AsString(key))) {
+      if (STREQ(key_lookup, PyUnicode_AsUTF8(key))) {
         return value;
       }
     }
@@ -6189,7 +6189,7 @@ static PyObject *pyrna_func_call(BPy_FunctionRNA *self, PyObject *args, PyObject
 #ifdef DEBUG_STRING_FREE
     if (item) {
       if (PyUnicode_Check(item)) {
-        PyList_APPEND(string_free_ls, PyUnicode_FromString(_PyUnicode_AsString(item)));
+        PyList_APPEND(string_free_ls, PyUnicode_FromString(PyUnicode_AsUTF8(item)));
       }
     }
 #endif
@@ -6245,7 +6245,7 @@ static PyObject *pyrna_func_call(BPy_FunctionRNA *self, PyObject *args, PyObject
 
     while (PyDict_Next(kw, &pos, &key, &value)) {
 
-      arg_name = _PyUnicode_AsString(key);
+      arg_name = PyUnicode_AsUTF8(key);
       found = false;
 
       if (arg_name == NULL) { /* Unlikely the argname is not a string, but ignore if it is. */
@@ -7664,7 +7664,7 @@ static PyObject *pyrna_basetype_getattro(BPy_BaseTypeRNA *self, PyObject *pyname
 {
   PointerRNA newptr;
   PyObject *ret;
-  const char *name = _PyUnicode_AsString(pyname);
+  const char *name = PyUnicode_AsUTF8(pyname);
 
   if (name == NULL) {
     PyErr_SetString(PyExc_AttributeError, "bpy.types: __getattr__ must be a string");
@@ -7675,14 +7675,14 @@ static PyObject *pyrna_basetype_getattro(BPy_BaseTypeRNA *self, PyObject *pyname
     if (ret == NULL) {
       PyErr_Format(PyExc_RuntimeError,
                    "bpy.types.%.200s subtype could not be generated, this is a bug!",
-                   _PyUnicode_AsString(pyname));
+                   PyUnicode_AsUTF8(pyname));
     }
   }
   else {
 #if 0
     PyErr_Format(PyExc_AttributeError,
                  "bpy.types.%.200s RNA_Struct does not exist",
-                 _PyUnicode_AsString(pyname));
+                 PyUnicode_AsUTF8(pyname));
     return NULL;
 #endif
     /* The error raised here will be displayed. */
@@ -7889,12 +7889,12 @@ static int deferred_register_prop(StructRNA *srna, PyObject *key, PyObject *item
     if (PyArg_ParseTuple(item, "OO!", &py_func, &PyDict_Type, &py_kw)) {
       PyObject *args_fake;
 
-      if (*_PyUnicode_AsString(key) == '_') {
+      if (*PyUnicode_AsUTF8(key) == '_') {
         PyErr_Format(PyExc_ValueError,
                      "bpy_struct \"%.200s\" registration error: "
                      "%.200s could not register because the property starts with an '_'\n",
                      RNA_struct_identifier(srna),
-                     _PyUnicode_AsString(key));
+                     PyUnicode_AsUTF8(key));
         return -1;
       }
       py_srna_cobject = PyCapsule_New(srna, NULL, NULL);
@@ -7938,7 +7938,7 @@ static int deferred_register_prop(StructRNA *srna, PyObject *key, PyObject *item
                      "bpy_struct \"%.200s\" registration error: "
                      "%.200s could not register\n",
                      RNA_struct_identifier(srna),
-                     _PyUnicode_AsString(key));
+                     PyUnicode_AsUTF8(key));
         return -1;
       }
     }
@@ -7992,7 +7992,7 @@ static int pyrna_deferred_register_props(StructRNA *srna, PyObject *class_dict)
         }
         printf("    assign as a type annotation: %.200s.%.200s\n",
                RNA_struct_identifier(srna),
-               _PyUnicode_AsString(key));
+               PyUnicode_AsUTF8(key));
       }
       ret = deferred_register_prop(srna, key, item);
 
@@ -9088,7 +9088,7 @@ static PyObject *pyrna_bl_owner_id_set(PyObject *UNUSED(self), PyObject *value)
     name = NULL;
   }
   else if (PyUnicode_Check(value)) {
-    name = _PyUnicode_AsString(value);
+    name = PyUnicode_AsUTF8(value);
   }
   else {
     PyErr_Format(PyExc_ValueError,
diff --git a/source/blender/python/intern/bpy_traceback.c b/source/blender/python/intern/bpy_traceback.c
index e2c894e90f82..00b414e027ef 100644
--- a/source/blender/python/intern/bpy_traceback.c
+++ b/source/blender/python/intern/bpy_traceback.c
@@ -149,7 +149,7 @@ void python_script_error_jump(const char *filepath, int *lineno, int *offset)
       PyObject *filename_py, *text_py;
 
       if (parse_syntax_error(value, &message, &filename_py, lineno, offset, &text_py)) {
-        const char *filename = _PyUnicode_AsString(filename_py);
+        const char *filename = PyUnicode_AsUTF8(filename_py);
         /* python adds a '/', prefix, so check for both */
         if ((BLI_path_cmp(filename, filepath) == 0) ||
             (ELEM(filename[0], '\\', '/') && BLI_path_cmp(filename + 1, filepath) == 0)) {
diff --git a/source/blender/python/mathutils/mathutils_Euler.c b/source/blender/python/mathutils/mathutils_Euler.c
index ebc71706bef5..f2a8af18073f 100644
--- a/source/blender/python/mathutils/mathutils_Euler.c
+++ b/source/blender/python/mathutils/mathutils_Euler.c
@@ -670,7 +670,7 @@ static int Euler_order_set(EulerObject *self, PyObject *value, void *UNUSED(clos
     return -1;
   }
 
-  if (((order_str = _PyUnicode_AsString(value)) == NULL) ||
+  if (((order_str = PyUnicode_AsUTF8(value)) == NULL) ||
       ((order = euler_order_from_string(order_str, "euler.order")) == -1)) {
     return -1;
   }
diff --git a/source/blender/python/mathutils/mathutils_Matrix.c b/source/blender/python/mathutils/mathutils_Matrix.c
index 87d16656d705..016ba4620300 100644
--- a/source/blender/python/mathutils/mathutils_Matrix.c
+++ b/source/blender/python/mathutils/mathutils_Matrix.c
@@ -499,7 +499,7 @@ static PyObject *C_Matrix_Rotation(PyObject *cls, PyObject *args)
   }
 
   if (vec && PyUnicode_Check(vec)) {
-    axis = _PyUnicode_AsString((PyObject *)vec);
+    axis = PyUnicode_AsUTF8((PyObject *)vec);
     if (axis == NULL || axis[0] == '\0' || axis[1] != '\0' || axis[0] < 'X' || axis[0] > 'Z') {
       PyErr_SetString(PyExc_ValueError,
                       "Matrix.Rotation(): "
@@ -768,7 +768,7 @@ static PyObject *C_Matrix_OrthoProjection(PyObject *cls, PyObject *args)
 
   if (PyUnicode_Check(axis)) { /* ortho projection onto cardinal plane */
     Py_ssize_t plane_len;
-    const char *plane = _PyUnicode_AsStringAndSize(axis, &plane_len);
+    const char *plane = PyUnicode_AsUTF8AndSize(axis, &plane_len);
     if (matSize == 2) {
       if (plane_len == 1 && plane[0] == 'X') {
         mat[0] = 1.0f;
diff --git a/source/blender/python/mathutils/mathutils_Quaternion.c b/source/blender/python/mathutils/mathutils_Quaternion.c
index 8d2ab614728a..3bc60190d561 100644
--- a/source/blender/python/mathutils/mathutils_Quaternion.c
+++ b/source/blender/python/mathutils/mathutils_Quaternion.c
@@ -195,7 +195,7 @@ static PyObject *Quaternion_to_swing_twist(QuaternionObject *self, PyObject *axi
   int axis;
 
   if (axis_arg && PyUnicode_Check(axis_arg)) {
-    axis_str = _PyUnicode_AsString(axis_arg);
+    axis_str = PyUnicode_AsUTF8(axis_arg);
   }
 
   if (axis_str && axis_str[0] >= 'X' && axis_str[0] <= 'Z' && axis_str[1] == 0) {
